# Usage:
# 1. mkdir -p $HOME/Workspace/aaroey
# 2. copy & paste the content in ../../docker/root/.bashrc to your ~/.bashrc
#
# For mac, to update to newest bash, do:
# $ brew update && brew install bash
# $ sudo bash -c 'echo /usr/local/bin/bash >> /etc/shells'
# $ chsh -s /usr/local/bin/bash 
# Then restart all the terminals.

################################# Init scripts #################################

# The local root of the cloned repository.
AAROEY_LIB_DIR=$HOME/Workspace/aaroey/aaroey-lib
AAROEY_LIB_CONFIG_COMMON_DIR=$AAROEY_LIB_DIR/config/common
DOCKER_ROOT=$HOME/Workspace/dockerroot

init_inputrc() {
  if ! [[ -f $HOME/.inputrc.oss_backup ]]; then
    if [[ -f $HOME/.inputrc ]]; then
      mv $HOME/.inputrc $HOME/.inputrc.oss_backup
    fi
    cp $AAROEY_LIB_CONFIG_COMMON_DIR/inputrc $HOME/.inputrc
  fi
}
make_docker_root() {
  if ! [[ -d $DOCKER_ROOT ]]; then
    cp -r $AAROEY_LIB_DIR/docker/root $DOCKER_ROOT
  fi
}
export_ps1() {
  # \a : an ASCII bell character (07)
  # \d : the date in "Weekday Month Date" format (e.g., "Tue May 26")
  # \D{format} :  the format is passed to strftime(3) and the result is inserted into the prompt string; an empty format results in a locale-specific time representation. The braces are required
  # \e : an ASCII escape character (033)
  # \h : the hostname up to the first '.'
  # \H : the hostname
  # \j : the number of jobs currently managed by the shell
  # \l : the basename of the shell’s terminal device name
  # \n : newline
  # \r : carriage return
  # \s : the name of the shell, the basename of $0 (the portion following the final slash)
  # \t : the current time in 24-hour HH:MM:SS format
  # \T : the current time in 12-hour HH:MM:SS format
  # \@ : the current time in 12-hour am/pm format
  # \A : the current time in 24-hour HH:MM format
  # \u : the username of the current user
  # \v : the version of bash (e.g., 2.00)
  # \V : the release of bash, version + patch level (e.g., 2.00.0)
  # \w : the current working directory, with $HOME abbreviated with a tilde
  # \W : the basename of the current working directory, with $HOME abbreviated with a tilde
  # \! : the history number of this command
  # \# : the command number of this command
  # \$ : if the effective UID is 0, a #, otherwise a $
  # \nnn : the character corresponding to the octal number nnn
  # \\ : a backslash
  # \[ : begin a sequence of non-printing characters, which could be used to embed a terminal control sequence into the prompt
  # \] : end a sequence of non-printing characters

  # \e[ : Start color scheme.
  # x;y : Color pair to use (x;y)
  # $PS1 : Your shell prompt variable.
  # \e[m : Stop color scheme.

  # A list of color codes (Note: You need to replace digit 0 with 1 to get light
  # color version).
  # Black  0;30  |  Blue   0;34  |  Green  0;32  |  Cyan   0;36  |  Red    0;31
  # Purple 0;35  |  Brown  0;33  |  Blue   0;34  |  Green  0;32  |  Cyan   0;36
  # Red    0;31  |  Purple 0;35  |  Brown  0;33

  # my_ps1="\[\e[32;1m\]\u@\[\e[36m\]\h\[\e[33m\]:\[\e[35;4m\]\W\[\e[0m\e[31;1m\]\$\[\e[0m\] "
  # my_ps1="\[\e[32;1m\]\u\[\e[33m\]@\[\e[36m\]\H\[\e[33m\]>\[\e[35;4m\]\w\[\e[0m\e[31;1m\]\n\$\[\e[0m\] "
  local my_ps1="\[\e[32;1m\]\u\[\e[33m\]@\[\e[36m\]\H\[\e[33m\]>\$(date '+%Y-%m-%d|%H:%M:%S')>\[\e[35;4m\]\w\[\e[0m\e[31;1m\]\n\$\[\e[0m\] "
  if [[ "$VIRTUAL_ENV" == '' ]]; then
    export PS1=$my_ps1
  else
    export PS1="(${VIRTUAL_ENV/*\//}) $my_ps1"
  fi
}
init_vim() {
  local source_oss_vim_cmd='source ~/Workspace/aaroey/aaroey-lib/config/common/vimrc'
  if ! [[ -f $HOME/.vimrc ]] || ! [[ $(grep "$source_oss_vim_cmd" $HOME/.vimrc) ]]; then
    echo "$source_oss_vim_cmd" >> $HOME/.vimrc
    ln -s $AAROEY_LIB_CONFIG_COMMON_DIR/ultisnips ~/.vim/ultisnips
  fi
}
init() {
  init_inputrc
  make_docker_root
  export_ps1
  init_vim
}
init

##################################### bash #####################################
# Size of the history file.
export HISTFILESIZE=10000000
# Number of commands be printed each time we run 'history' in bash.
export HISTSIZE=10000000
export EDITOR='vim'  # use 'gvim -f' if you want to use GUI vim.

NUM_MATCHES_TO_FIND=10000  # Stop after these many matches are found

sb() { exec bash; }
vimbashrc() {
  vim ~/.bashrc $AAROEY_LIB_DIR/config/common/bashrc "$@"
}
vimvimrc() {
  vim ~/.vimrc $AAROEY_LIB_DIR/config/common/vimrc "$@"
}
clearscreen() {
  clear && echo -en "\e[3J"
}
findfileslargerthan() {
  local filename_output=$(mktemp /tmp/XXXXXX)
  local largest_fileinfo_output=$(mktemp /tmp/XXXXXX)

  echo "Writing large file names output to $filename_output ..."
  # Find files larger than $2 and sort them by size
  find "${1:-$HOME}" -type f -size +"${2:-50M}" -ls | sort -nr -k 7,7 | sed 's/^[^/]*//' > $filename_output

  echo "Writing largest file info output to $largest_fileinfo_output ..."
  (while IFS= read -r i; do ls -alh -color "$i"; done) < $filename_output > $largest_fileinfo_output
  head -n 20 $largest_fileinfo_output
}
# We can add option -l to grep to show only filename instead of matched content
fgpdir() {
  # $1 is command (whether to use xargs or not)
  # $2 directory
  # $3 is pattern
  local option_h=''
  if [[ "$1" == xargs ]]; then option_h='-H'; fi
  find -L "$2" -type f | $1 grep $option_h -m $NUM_MATCHES_TO_FIND --color "$3" 2>/dev/null
}
grepfile() {
  local pattern="$1"
  shift
  grep -H -m $NUM_MATCHES_TO_FIND --color "$pattern" "$@"
}
fgptmpl() {
  case "$#" in
    0) echo 'Usage: fgptmpl [file_or_dir_1 [file_or_dir_2...]] pattern';;
    1) fgpdir xargs . "$1";;
    2) fgpdir xargs "$1" "$2";;
    *)
      until [[ $# -eq 1 ]]; do
        if test -d "$1"; then
          fgpdir xargs "$1" "${!#}"
        else
          grepfile "${!#}" "$1"
        fi
        shift
      done
      ;;
  esac
}
lgptmpl() {
  case "$#" in
    1) fgpdir '' . "$1";;
    2) fgpdir '' "$1" "$2";;
    *) echo 'Only one or two arguments are accepted!';;
  esac
}
lgpltemp() {
  # lgp + ls
  lgptmpl "$@" | xargs ls -alhF | grep "$@" --color
}
fgp()    { NUM_MATCHES_TO_FIND=10000; fgptmpl "$@"; }
fgp1()   { NUM_MATCHES_TO_FIND=1;     fgptmpl "$@"; }
lgp()    { NUM_MATCHES_TO_FIND=10000; lgptmpl "$@"; }
lgpl()   { NUM_MATCHES_TO_FIND=10000; lgpltemp "$@"; }
lgp1()   { NUM_MATCHES_TO_FIND=1;     lgpltemp "$@"; }
lfgp()   {
  NUM_MATCHES_TO_FIND=10000
  case "$#" in
    0) ;&
    1)
      echo 'Usage: lfgp file_name_pattern_1 [file_name_pattern_2 ...] file_content_pattern'
      echo 'Note that to match special characters like "-" or "*" we need the antislash.'
      return;;
  esac
  local out="$(find -L . -type f)"
  while (( $# > 1 )); do
    out=$(echo "$out" | grep "$1")
    shift
  done
  echo "$out" | xargs grep -H -m $NUM_MATCHES_TO_FIND --color "$1" 2>/dev/null
}
psgp()   { ps -AlF | grep --color "^F \+S \+UID \+PID \+PPID \+.\+ \+SZ \+.\+ \+RSS \+.\+ \+STIME \+TTY \+TIME \+CMD\|$@"; }
du0()    { du -d 0 -h $@;                           }
dutop()  { du -a -h "$@" | sort -r -h | head -n 30; }
ll()     { ls -alhF --color "$@";                   }
llpwd()  { for i in "$@"; do ll -d -1 "$PWD/$i"; done }

# date
# Timezones: ll /usr/share/zoneinfo/
datesecond()      { date +%s;                                 }
datems()          { echo $(($(date +%s%N)/1000000));          }  # milliseconds
dateus()          { echo $(($(date +%s%N)/1000));             }  # microsecods
datens()          { date +%s%N;                               }  # nanoseconds

datetotmpl()      { date -d"$1" '+%s%N';                      }
datetoseconds()   { echo $(($(datetotmpl "$1")/1000000000));  }  # e.g.: datetoseconds '2013-01-01 12:12:12'
datetoms()        { echo $(($(datetotmpl "$1")/1000000));     }  # e.g.: datetoms '2013-01-01 12:12:12'
datetous()        { echo $(($(datetotmpl "$1")/1000));        }  # e.g.: datetous '2013-01-01 12:12:12'
datetons()        { datetotmpl "$1";                          }  # e.g.: datetons '2013-01-01 12:12:12'

# How to use xargs with date: xargs -I^ date -d@"^" '+%Y-%m-%d %H:%M:%S.%N'
datelocal() {
  if [[ "$1" == '--pretty' ]] || [[ "$1" == '-p' ]]; then
    date '+%Y-%m-%d-%H:%M:%S.%N'
  else
    date '+%Y-%m-%d-%H-%M-%S'
  fi
}
datefromtmpl() {
  echo 'local time:' $(date -d@$1 '+%Y-%m-%d-%H:%M:%S.%N')
  echo 'UTC:' $(TZ=UTC date -d@$1 '+%Y-%m-%d-%H:%M:%S.%N')
}
datefromseconds() { datefromtmpl $1;                          }  # e.g.: datefromseconds 1449687592.462323056
datefromms()      { datefromtmpl $(echo $1/1000 | bc);        }  # e.g.: datefromms 1449687592462.323056
datefromus()      { datefromtmpl $(echo $1/1000000 | bc);     }  # e.g.: datefromus 1449687592462323.056
datefromns()      { datefromtmpl $(echo $1/1000000000 | bc);  }  # e.g.: datefromns 1449687592462323056
# Some weird seconds: datefromseconds 9971999 diffs with datefromseconds 9972000 with 1 hour!!!

# number base transform
base8to10()  { local num; ((num=0${1})); echo $num;       }
base16to10() { local num; ((num=0x${1})); echo $num;      }
baseto10()   { local num; ((num=${1}'#'${2})); echo $num; }
basefrom10() { echo "obase=$1;$2" | bc;                   }

lddclean() {
  LD_LIBRARY_PATH= ldd "$@"
}

hist() {
  local last_n=10
  if [[ $1 =~ ^[0-9]+$ ]]; then
    last_n=$1
    shift
  fi
  # Read the history file
  history -r
  if [[ $# -lt 1 ]]; then
    history $last_n
  else
    # HISTSIZE is set to large enough to print all history
    history | grep --color "$@" | tail -n $last_n
  fi
}
ht() {
  local last_n=20
  # http://stackoverflow.com/questions/806906/how-do-i-test-if-a-variable-is-a-number-in-bash
  # if [ "$1" -eq "$1" ] 2>/dev/null; then
  if [[ $1 =~ ^[0-9]+$ ]]; then
    last_n=$1
    shift
  fi
  if [[ $# -lt 1 ]]; then
    tail -n $[last_n*20] $HISTFILE | grep -v '^#'
  else
    grep "$@" $HISTFILE | tail -n $[last_n*20]
  fi | sed 's/ *$//g'  \
     | nl -n rz        \
     | sort -k2 -k1,1r \
     | uniq -s 8       \
     | sort            \
     | tail -n $last_n \
     | sed 's/^[0-9]\+\t*//'
}
# export PROMPT_COMMAND='history -a; history -r'
# export PROMPT_COMMAND="history -a; history -c; history -r; $PROMPT_COMMAND"
export AAROEY_OLD_PROMPT_COMMAND="$PROMPT_COMMAND"
export PROMPT_COMMAND="history -a; $PROMPT_COMMAND"
uniqbashhistory() {
  local tmpfile=/tmp/bash-history-$RANDOM
  local backupfile=$tmpfile.bak
  echo "Backing up $HISTFILE to $backupfile..."
  cp "$HISTFILE" "$backupfile"
  echo "Trimming $HISTFILE..."
  cat "$HISTFILE" \
    | nl | sort -k2 -k 1,1nr | uniq -f1 | sort -n | cut -f2 | uniq -w3 \
    > $tmpfile
  mv $tmpfile "$HISTFILE"
  echo "Done."
}

# Config file for bc
export BC_ENV_ARGS=~/.bcrc

# Vim mode in Bash, see http://blog.sanctum.geek.nz/vi-mode-in-bash/
set -o vi

export -f sb fgp fgp1 lgp lgp1 psgp du0 ll datelocal datesecond datems dateus datens datetotmpl datetoseconds datetoms datetous datetons datefromtmpl datefromseconds datefromms datefromus datefromns base8to10 base16to10 baseto10 basefrom10 lddclean

##################################### git ######################################
gitdiffeditable() {
  if [[ $# -ne 2 ]]; then
    echo 'Usage: gitdiffeditable version file'
    echo 'E.g.:
    gitdiffeditable master~10 my_file
    gitdiffeditable upstream/tensorrt~10 my_file
    gitdiffeditable 825e7a32e9f4dbad21a9ddb9d8a34bd3e32b1d0e my_file'
    return
  fi
  local tmp_file="/tmp/$RANDOM-${1//\//_}:${2//\//_}"
  # See 'git help revisions' about how to specify refs.
  git show "$1:$2" > "$tmp_file"
  vimdiff "$tmp_file" "$2" -c ':se ro' -c 'wincmd l' -c ':se noreadonly'
}
GIT_LOG_FORMAT='%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(blue)<%an> %C(magenta)[%ae]%Creset'
GIT_LOG_FORMAT_SIMPLE='%h -%d %s (%cr) <%an> [%ae]'
gitgraph() {
  local format=$GIT_LOG_FORMAT
  if [[ $1 == '--simple' ]]; then
    format=$GIT_LOG_FORMAT_SIMPLE
    shift
  fi
  if [[ $# -eq 0 ]]; then
    set -- --all
  fi
  git log --color --graph --abbrev-commit --pretty=format:"$format" "$@"
}
gitvimmodified() {
  vim $(git st --porcelain | sed -ne 's/^ M //p')
}
gitdiffLCA() {
  if [[ "$1" == '-h' ]] || [[ "$1" == '--help' ]] || [[ "$1" == '?' ]]; then
    echo 'Usage: gitdiffLCA [master, etc] [--name-only, --no-pager, and/or other options]'
    echo 'If it prompts `Not a valid object name upstream:master` we need to do `git fetch upstream` first.'
    return
  fi
  local against=$1
  if [[ "$#" -eq 0 ]] || [[ "$1" == '--'* ]]; then
    against=master  # or upstream/master
  else
    shift
  fi
  local head=HEAD  # or FETCH_HEAD
  local merge_base=$(git merge-base $against $head)
  echo "Merge base: $merge_base"
  git diff $@ $merge_base $head --
}
gitpurgecommithistory() {
  local answer=No
  read -p 'Are you sure to purge all commit log? No/yes: ' answer
  if [[ "$answer" == 'yes' ]]; then
    answer=No
    read -p 'Are you really sure? No/yes: ' answer
    if [[ "$answer" == 'yes' ]]; then
      git checkout --orphan latest_branch
      git add -A
      git commit -am "Rebase"
      git branch -D master
      git branch -m master
      git push -f origin master
    fi
  fi
}
gitfixauthorandemails() {
  if [[ $# -lt 2 ]] || [[ $# -gt 3 ]]; then
    echo 'Usage: gitfixauthorandemails <correct_author> <correct_email> [<old_email>]'
    return
  fi
  local correct_author=$1
  local correct_email=$2
  local old_email=$3

  git filter-branch --env-filter '
    CORRECT_NAME="'"$correct_author"'"
    CORRECT_EMAIL="'"$correct_email"'"
    if [[ '"$old_email"' == "" ]] || [[ "$GIT_COMMITTER_EMAIL" == '"$old_email"' ]]; then
      export GIT_COMMITTER_NAME="$CORRECT_NAME"
      export GIT_COMMITTER_EMAIL="$CORRECT_EMAIL"
      export GIT_AUTHOR_NAME="$CORRECT_NAME"
      export GIT_AUTHOR_EMAIL="$CORRECT_EMAIL"
    fi
    ' --tag-name-filter cat -- --branches --tags
  # See https://stackoverflow.com/questions/7654822/remove-refs-original-heads-master-from-git-repo-after-filter-branch-tree-filte for details.
  echo "Updated the author and email of all local commits."
  echo "Next step: after carefully reviewing the changed history, run:"
  echo "$ git push --force --tags origin 'refs/heads/*'"
  echo "$ git update-ref -d refs/original/refs/heads/master"
  echo "For a different client repo which tracks the origin, run:"
  echo "$ git checkout master"
  echo "$ git reset --hard origin/master"
}
gitcommitpush() {
  git add -u
  git commit -m "$@"
  git push origin master
}
gitpushrelogin() {
  # Useful to push a repository with a credential that is different than the
  # default one.
  # See https://stackoverflow.com/questions/13198143/how-do-i-disable-gits-credential-helper-for-a-single-repository/13203623#13203623
  local branch=${1:-master}
  git -c credential.helper= push origin $branch
}
# Useful commands:
# - $ git remote set-url origin https://<user>@github.com/<user>/<user>.github.io
# - To fix the identity used for the last commit **after** changing
#   user.name/email globally:
#   $ git commit --amend --reset-author

##################################### tmux #####################################
new_tmux_session() {
  if [[ $# -ne 20 ]]; then
    echo 'Usage:'
    echo '  new_tmux_session <win0> <path0> <win1> <path1> ... <win9> <path9>'
    return
  fi
  local session=mysession-$1
  local anysession=$(tmux ls)
  local running=$(echo $anysession | grep -o $session)
  # echo $anysession
  # echo $running

  if [[ $running ]]; then
    tmux attach -d -t $session
    return
  fi

  local tmpconfig=~/.tmux.conf
  if [[ $anysession ]]; then
    tmpconfig=/tmp/tmux.conf.$1
  fi

  cat $AAROEY_LIB_CONFIG_COMMON_DIR/.tmux_config_tmpl        \
    | sed "s/<mysession>/$session/g"                        \
    | sed "s/<window0>/$1/g"    | sed "s#<path0>#$2#g"      \
    | sed "s/<window1>/$3/g"    | sed "s#<path1>#$4#g"      \
    | sed "s/<window2>/$5/g"    | sed "s#<path2>#$6#g"      \
    | sed "s/<window3>/$7/g"    | sed "s#<path3>#$8#g"      \
    | sed "s/<window4>/$9/g"    | sed "s#<path4>#${10}#g"   \
    | sed "s/<window5>/${11}/g" | sed "s#<path5>#${12}#g"   \
    | sed "s/<window6>/${13}/g" | sed "s#<path6>#${14}#g"   \
    | sed "s/<window7>/${15}/g" | sed "s#<path7>#${16}#g"   \
    | sed "s/<window8>/${17}/g" | sed "s#<path8>#${18}#g"   \
    | sed "s/<window9>/${19}/g" | sed "s#<path9>#${20}#g"   \
    > $tmpconfig
  if [[ $anysession ]]; then
    tmux source $tmpconfig
    tmux attach -t $session
  else
    tmux attach
  fi
}
# -d means to detach other attached clients
tt() { tmux attach -d -t "$@"; }
td() { tmux detach "$@"; }
tsendkey() {
  local session=$1
  shift
  tmux send-keys -t mysession:$session "$@" C-m
}

################################# nvidia gpu ###################################
cuda_version() {
  # This doesn't work under some system.
  # nvidia-smi | grep -o CUDA.* | sed 's/CUDA Version: //g;s/ .*//g'
  nvcc --version | grep -o  release.* | sed 's/release //g;s/,.*//g'
}

export -f cuda_version

#################################### docker ####################################
# docker image prune -a
# docker container prune
dockerimages() {
  docker images | grep -v '^REPOSITORY' | sort
}
dockerpullalllocalimages() {
  docker images | grep -v REPOSITORY | awk '{print $1":"$2}' | xargs -L1 docker pull
}
dockerprune_containers_and_images() {
  docker container prune -f
  docker image prune -f
}
docker_run_with_nvidia() {
  # We can also do the following instead of -v:
  # --mount type=bind,source=<src>,target=<dst>
  local tag="$1"
  shift
  docker run $@ --runtime=nvidia \
    -v /tmp:/tmp \
    -v $DOCKER_ROOT:/root \
    -it "$tag" bash
}
dockertf() {
  # Don't do --rm.
  # Remember to run `docker commit <hash> <tag>` after changing something in the
  # container.
  local tftag=tensorflow/tensorflow:nightly-gpu
  local mytag=lam8da/tf-nightly-gpu:latest
  local tag=$tftag
  if [[ "$(docker images | grep $mytag)" ]]; then
    tag=$mytag
  fi
  # nvidia-docker is also fine.
  docker_run_with_nvidia "$tag"
}
dockerrunsimplewithbash() {
  local mydockerrepo=lam8da/aaroey-env
  local tag=${1:-$mydockerrepo}
  if [[ "$tag" == $mydockerrepo ]]; then
    local cuda_major=${cuda_major:-9}
    local cuda_minor=${cuda_minor:-0}
    local cudnn_major=${cudnn_major:-7}
    local cudnn_version_suffix=${cudnn_version_suffix:-5.1.10}
    local tensorrt_version=${tensorrt_version:-5.1.5}
    local tag_suffix=cuda${cuda_major}.${cuda_minor}-cudnn${cudnn_major}.${cudnn_version_suffix}-nvinfer${tensorrt_version}
    tag=$mydockerrepo:$tag_suffix

    local found="$(docker pull $tag)"
    if ! [[ "$found" ]]; then
      local tmpdir=$(mktemp -d)
      mkdir -p $tmpdir
      pushd $tmpdir
      docker build --pull -t $tag \
        --build-arg CUDA_MAJOR_VERSION=${cuda_major} \
        --build-arg CUDA_MINOR_VERSION=${cuda_minor} \
        --build-arg CUDNN_MAJOR_VERSION=${cudnn_major} \
        --build-arg CUDNN_VERSION_SUFFIX=${cudnn_version_suffix} \
        --build-arg TENSORRT_VERSION=${tensorrt_version} \
        -f $AAROEY_LIB_DIR/dockerfiles/devel-gpu.Dockerfile ./ \
        && docker push $tag
      popd
    fi
  else
    docker pull "$tag"
  fi
  # Adding --net=host will change PS1 to **NOT** show the hash.
  docker_run_with_nvidia "$tag" --rm
}

################################## virtualenv ##################################
virtualenv_pip_install() {
  if [[ "$VIRTUAL_ENV" == "" ]]; then
    >&2 echo 'Error: must be run inside a virtual env!'
    return
  fi
  if [[ "$#" -lt 1 ]]; then
    >&2 echo 'Usage: virtualenv_pip_install <python_version> [<packages>...]'
    return
  fi
  local pyver=$1
  shift
  python$pyver -m pip install --upgrade "$@"
}
VIRTUALENV_ALREADY_ACTIVATED_ERROR_CODE=412434
already_in_virtualenv() {
  if [[ "$VIRTUAL_ENV" != "" ]]; then
    echo "Already inside a virtualenv environment: $VIRTUAL_ENV"
  else
    echo ''
  fi
}
OLD_PYTHONPATH=''
virtualenv_activate() {
  if [[ $# -ne 2 ]]; then
    echo 'Usage: activate_virtualenv <absolute_virtualenv_dir> <python_version>'
    return
  fi
  local vedir="$1"
  if [[ $vedir == '' ]]; then
    echo 'virtualenv dir must not be empty!'
    return
  fi
  if [[ "$VIRTUAL_ENV" == "$vedir" ]]; then
    echo 'Already inside the same virtualenv environment, skipping...'
    return
  elif [[ "$VIRTUAL_ENV" != "" ]]; then
    echo "Already inside a different virtualenv environment $VIRTUAL_ENV"
    echo "Please deactivate and try again."
    return $VIRTUALENV_ALREADY_ACTIVATED_ERROR_CODE
  fi

  local pyver="$2"
  local activate_file="$vedir/bin/activate"

  # This is very important! If not using a new dir, when importing modules,
  # python will import from current dir first! If current dir has a sub dir
  # whose name is the same as the module it will then import the pyc file from
  # that sub dir!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  local tmp_working_dir=/tmp/virtualenv/tmp-$RANDOM
  mkdir -p $tmp_working_dir
  pushd $tmp_working_dir

  if [[ ! -f "$activate_file" ]]; then
    mkdir -p $vedir
    # ****!!!! Do not use --system-site-packages !!!!****
    # Otherwise pip will install all packages to system site-packages dir!!!!!
    virtualenv -p python$pyver $vedir
  fi

  source "$activate_file"
  # Note @2018/12/06: recordclass, scrapy is not py36 compatible
  virtualenv_pip_install $pyver \
    mock ipython recordclass Pillow jupyter numpy \
    selenium beautifulsoup4 requests scrapy bs4 lxml pymysql \
    Faker \
    img2html pandas nltk soundfile sox matplotlib \
    keras_applications keras_preprocessing tensorflow-serving-api

  # if [[ $pyver == '3' ]]; then
  #   virtualenv_pip_install $pyver something
  # fi

  # Change the PYTHONPATH:
  # OLD_PYTHONPATH=$PYTHONPATH
  # export PYTHONPATH=$(python -c "import sys; site_packages = next(p for p in sys.path if 'site-packages' in p); print(site_packages)")

  popd
  echo '--> PYTHONPATH:' $PYTHONPATH
  echo '--> PATH:' $PATH
  echo '--> LD_LIBRARY_PATH:' $LD_LIBRARY_PATH
}
virtualenv_deactivate() {
  deactivate
  # export PYTHONPATH=$OLD_PYTHONPATH
}
vadtmpl() {
  local usage='Usage: vadtmpl nightly|<empty> py2|py3 <workspace>'
  if [[ $# -ne 2 ]] && [[ $# -ne 3 ]]; then
    echo $usage
    return
  fi
  local tag=$1
  local pyverstr=$2

  local pyver=''
  if [[ "$pyverstr" == 'py3' ]]; then
    pyver=3
  elif [[ "$pyverstr" == 'py2' ]]; then
    pyver=2
  else
    echo 'Error: python version not specified correctly.'
    echo $usage
    return
  fi

  local dir=$HOME/tmp
  local veworkspace=$dir/default_virtualenv_workspace
  local tfpkg=''
  if [[ "$tag" == 'nightly' ]]; then
    tfpkg='tf-nightly-gpu'
  elif [[ "$tag" == 'nightlyv2' ]]; then
    tfpkg='tf-nightly-gpu-2.0-preview'   # See https://pypi.org/project/tf-nightly-gpu-2.0-preview/#history
  elif [[ "$tag" == '' ]]; then
    tfpkg='tensorflow-gpu'
  else
    dir=~/Workspace/aaroey/$tag
  fi
  local vedir="$dir/virtualenv_${pyverstr}"
  if [[ "$tfpkg" != '' ]]; then
    vedir="$vedir=$tfpkg"
  fi

  virtualenv_activate $vedir $pyver

  # Change to the working dir first before installing new packages. This is very
  # important!! See comments in virtualenv_activate() for more information.
  mkdir -p $veworkspace
  pushd $veworkspace
  if [[ "$tfpkg" ]]; then
    virtualenv_pip_install $pyver $tfpkg
  fi
  if [[ "$3" ]]; then
    popd
    pushd "$3"
  fi
}
dav() {
  virtualenv_deactivate
  popd
}
vad()          { vadtmpl '' py3 "$@";        }
vadnightly()   { vadtmpl nightly py3 "$@";   }
vadnightlyv2() { vadtmpl nightlyv2 py3 "$@"; }
vadmytfpy()    { vadtmpl mytfpy3 py3 "$@";   }
vadmytf2py()   { vadtmpl mytf2py3 py3 "$@";  }

export -f already_in_virtualenv virtualenv_activate virtualenv_deactivate virtualenv_pip_install vadtmpl dav

##################################### misc #####################################

# Setting evoluent mouse button mappings, see
# - https://shkspr.mobi/blog/2011/06/review-evoluent-vertical-mouse-4-and-how-to-make-it-work-in-ubuntu/
# - http://www.mrericsir.com/blog/technology/using-an-evoluent-verticalmouse-4-on-linux/
# - http://wiki.mbirth.de/know-how/software/linux/remapping-mouse-buttons.html
# - http://wiki.mbirth.de/know-how/hardware/evoluent-verticalmouse.html
#
# $ xinput list
# > ↳ Kingsis Peripherals Evoluent VerticalMouse 4   id=12   [slave pointer (2)]
# In following the <device-id> is 12 for the above case.
#
# Press and hold some button and run the this will tell you which id is down:
# $ xinput query-state <device-id>
# Re-map the buttons:
#                           input id: 1 2 3 4 5 6 7 8 9 10 11
# $ xinput set-button-map <device-id> 1 2 3 4 5 0 0 9 0 8
#
# To make it persistent:
# $ lsusb | grep 'Evoluent VerticalMouse'
# > Bus 002 Device 005: ID 1a7c:0191 Evoluent VerticalMouse 4
# $ sudo touch /usr/share/X11/xorg.conf.d/90-evoluent.conf
# $ sudo gedit /usr/share/X11/xorg.conf.d/90-evoluent.conf
# then put:
# Section "InputClass"
#   Identifier "Evoluent"
#   MatchUSBID "1a7c:0191"
#   Option "ButtonMapping" "1 2 3 4 5 0 0 9 0 8 0"
# EndSection

# use '[' as delimeter and the second part as key in number order
# sort -t [ -k 2 -n

# bash in vi-mode you can press v in normal mode to edit the command similarly
# to Ctrl-X Ctrl-E

X_SET=''
# TODO(aaroey): use a stack to record the sequence of calls to these methods and
# pop the last state in reset_x
set_x_if_not_set() {
  if [[ "$-" == *x* ]]; then
    X_SET=1
  else
    X_SET=0
    set -x
  fi
}
unset_x_if_set() {
  if [[ "$-" == *x* ]]; then
    set +x
    X_SET=1
  else
    X_SET=0
  fi
}
reset_x() {
  if [[ $X_SET ]]; then
    set -x
  else
    set +x
  fi
}
printsplitline() {
  local console_width=$(tput cols)
  # local console_width=$COLUMNS  # Seems not working in embedded shell.
  local prefix=${1:-''}
  local suffix=${2:-''}
  local prefix_len=${#prefix}
  local suffix_len=${#suffix}
  local line_len=$[$console_width-$prefix_len-$suffix_len]
  >&2 printf "$prefix"
  >&2 printf '=%.0s' $(seq 1 ${line_len})
  >&2 printf "$suffix"
  >&2 echo
}
printsplitlines() {
  printsplitline
  printsplitline "$@"
}
printsplitlinesnox() {
  unset_x_if_set
  printsplitlines "$@"
  reset_x
}
runperiodically() {
  for ((i=0;i<1000;++i)); do
    echo $i $@
    $@
  done
}
